<erl>
-record(input, {player_id, battlemap_id, instance_id}).

-include("/tmp/timed_cache_data.hrl").

parse_input (Req) ->
   JSONReqMap = jiffy:decode(Req, [return_maps]),
   #input
   {
      player_id = maps:get(<<"player_id">>, JSONReqMap),
      battlemap_id = maps:get(<<"battlemap_id">>, JSONReqMap),
      instance_id = maps:get(<<"instance_id">>, JSONReqMap)
   }.

generate_set_map (Battlemap) ->
   jiffy:encode
   (
      {
         [
            {<<"width">>, Battlemap#battlemap.width},
            {<<"height">>, Battlemap#battlemap.height},
            {<<"content">>, array:to_list(Battlemap#battlemap.content)}
         ]
      }
   ).

generate_add_char (Char, CharInstance) ->
   jiffy:encode
   (
      {
         [
            {<<"id">>, Char#character.id},
            {<<"name">>, Char#character.name},
            {<<"icon">>, Char#character.icon},
            {<<"portrait">>, Char#character.portrait},
            {<<"loc_x">>, CharInstance#character_instance.x},
            {<<"loc_y">>, CharInstance#character_instance.y},
            {<<"team">>, CharInstance#character_instance.team},
            {<<"mov_pts">>, Char#character.mov_pts},
            {<<"atk_rg">>, Char#character.atk_rg}
         ]
      }
   ).

generate_reply (Battlemap, _BattlemapInstance, Characters) ->
   jiffy:encode
   (
      [
         [
            <<"set_map">>,
            generate_set_map(Battlemap)
         ]
         |
         lists:map
         (
            fun ({CharID, CharInstance}) ->
               [
                  <<"add_char">>,
                  generate_add_char(CharID, CharInstance)
               ]
            end,
            Characters
         )
      ]
   ).

handle (Req) ->
   Input = parse_input(Req),
   Battlemap = timed_cache:fetch(battlemap_db, Input#input.battlemap_id),
   BattlemapInstance =
      timed_cache:fetch
      (
         battlemap_instance_db,
         <<"0">>
%         {Input#input.battlemap_id, Input#input.battlemap_instance_id}
      ),
   Characters =
      lists:map
      (
         fun ({CharID, CharInst}) ->
            {
               timed_cache:fetch(character_db, CharID),
               CharInst
            }
         end,
         dict:to_list(BattlemapInstance#battlemap_instance.chars)
      ),
   generate_reply(Battlemap, BattlemapInstance, Characters).

out(A) ->
   {
      content,
      "application/json; charset=UTF-8",
      handle(A#arg.clidata)
   }.
</erl>
